Python
======
While the TinTin++ scripting language is great (for what it's designed to do), it's not nearly as robust as python.  I spent a significant amount of time building *very* complex TinTin++ scripts before I finally decided it was time to begin migrating as much of my TinTin++ framework over to python.

Getting started with external script integrations is a little tricky, so I've built this guide to walk through the
process.


TinTin Commands
---------------
TinTin provides three distinct commands for interacting with external resources & scripts:

- [Run](http://tintin.sourceforge.net/manual/run.php)
- [Script](http://tintin.sourceforge.net/manual/script.php)
- [System](http://tintin.sourceforge.net/manual/system.php)

### The 'System' Command
Of the three commands, `#system` is the most straight forward. This *does not* return a value to TinTin - it simply
executes a command in the parent shell and the output is dumped straight to console. Some command examples that I use:

    #alias {clear} {#system clear}
    #alias {ls}    {#system ls}
    #alias {ll}    {#system ls -lah}
    #alias {pwd}   {#system pwd}


### The 'Script' Command
Next is the `#script` command. This is a little more complicated (than `#system`)- and acts differently based on the way in which it's called. The standard syntax is:

    #script {variable} {shell commands}

This just calls a script and stores any output generated by the script in the specified tintin variable, here's a couple examples:

    #script {result} {python -c 'print "Hello TinTin++"'}
    #VARIABLE {result}={{1}{Hello TinTin++}}

    #nop given the test.py script below ...
    #script {result} {test.py}
    #VARIABLE {result}={{1}{hello 01 from test.py}{2}{hello 02 from test.py}}

    #!/usr/bin/env python
    # test.py
    print('hello 01 from test.py')
    print('hello 02 from test.py')

Note: The variable is treated as a list, and each line output is stored in an index of that variable.

The `#run` command is more extensive than both `#script` and `#run` - it creates a new session and attaches the script/command to that session. This is done specifically with the intent of running interactive commands (i.e.  attaching an interpreter to a session). When the command ends the session also ends. The standard syntax for calling a script using `#run` is:

    #run {session name} {shell commands}

Given the script:

    #!/usr/bin/env python
    print('hello from test.py')

We can run it with the command `#run test.py`, which yields the output:

    hello from test.py
    #SESSION 'test'
    #SESSION 'gts' ACTIVATED

As expected, a new session named 'test' is started, the script dumps it's output, and the session dies. Not very useful - but we can make it do more interesting things. For example - we can startup a python interpreter and attach it to a session with:

    #run python python

We can now write python in our python session: `print('echo with python')` - and tintin script as well: `#showme hello!`.

Note: In a regular tintin session, and preceding whitespace before the `#` character is stripped out. In a `#run python python` session this does not happen and results in an intepretter error.

We can leave the python session running in the background and send commands to it (just like normal) which contain
python code that will be executed:

    #gts
    #python print("hello from #gts session")

Note: While we don't see the output in #gts, we can switch back to the python session (`#python`) and scroll through the
history buffer to see that the command was actually executed.

    #run python python;#act {^cmd %1} {%1};print "cmd #showme <118>Hello World!"




Examples:



### The "Script" Command
Examples:

    #script {path} {pwd}
    #script {variable} {shell commands}
    Example: #script {result} {lua -e 'print("Hello TinTin++")'
    Example: #script {result} {ruby -e 'print "Hello TinTin++"'}
    Example: #script {result} {python -c 'print "Hello TinTin++"'}
    Example: #script {result} {php -r 'echo "Hello TinTin++"'}
    Example: #script {result} {tcl -c 'puts "Hello TinTin++"'}


Note: If no variable argument is given the script output will be treated as tintin input, allowing you to use #showme and #send commands to process the output of a script. Keep in mind you can also execute script files.


### The "System" Command

Examples:

    #system {commands}



References
----------

- Threads on External Scripting
    - [Generic MySQL Connector](http://tintin.sourceforge.net/board/viewtopic.php?t=1112)
    - [Example Python Integration](http://tintin.sourceforge.net/board/viewtopic.php?t=2156)
    - [Python Scripting Help](http://tintin.sourceforge.net/board/viewtopic.php?t=1195)
    - [Using TinTin++ with an External Script](http://tintin.sourceforge.net/board/viewtopic.php?t=906)
- Repositories using Python:
    - [nstockton/tintin-mume](https://github.com/nstockton/tintin-mume)
    - [rascul/tintin-scripts](https://github.com/rascul/tintin-scripts)
    - [michael-n-kaplan/ta-scripts](https://github.com/michael-n-kaplan/ta-scripts)
    - [sunayforever/pkuxkx](https://github.com/sunwayforever/pkuxkx)
    - [twksos/pkuxkx_tintin](https://github.com/twksos/pkuxkx_tintin)
- Python Telnet Proxy
    - [PyBot](http://bazaar.launchpad.net/~pybot-team/pybot/src/files)
    - http://www.achaea.com/forum/python-telnet-proxy
    - http://stackoverflow.com/questions/7354864/http-through-telnet-with-python-and-twisted
    - http://www.mccarroll.net/snippets/simpleproxy/index.html
    - https://gist.github.com/night-crawler/6213578
- Mud-Related Python Projects
    - https://github.com/michael-donat/tf-mapper
    - https://github.com/michael-donat/MudMapper
    - https://github.com/talanis85/mudblood-py
    - https://github.com/endavis/bastproxy
    - https://github.com/Senso/Donginger
    - https://github.com/shuchton/wham_agent
